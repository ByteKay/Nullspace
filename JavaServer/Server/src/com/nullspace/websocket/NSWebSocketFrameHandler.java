package com.nullspace.websocket;/* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the "License"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */import java.util.Locale;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.websocketx.BinaryWebSocketFrame;import io.netty.handler.codec.http.websocketx.CloseWebSocketFrame;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import io.netty.handler.codec.http.websocketx.WebSocketFrame;import org.slf4j.Logger;import org.slf4j.LoggerFactory;/** * Echoes uppercase content of text frames. */public class NSWebSocketFrameHandler extends SimpleChannelInboundHandler<WebSocketFrame> {    private static final Logger logger = LoggerFactory.getLogger(NSWebSocketFrameHandler.class);    @Override    protected void channelRead0(ChannelHandlerContext ctx, WebSocketFrame frame) throws Exception {        // ping and pong frames already handled        if (frame instanceof TextWebSocketFrame) {            // Send the uppercase string back.            String request = ((TextWebSocketFrame) frame).text();            logger.info("{} received {}", ctx.channel(), request);            ctx.channel().writeAndFlush(new TextWebSocketFrame(request.toUpperCase(Locale.US)));        }         else if (frame instanceof BinaryWebSocketFrame)        {        	ByteBuf buf = ((BinaryWebSocketFrame)frame).content();        	// to do        	ctx.channel().writeAndFlush(new BinaryWebSocketFrame(buf));        }        else if (frame instanceof CloseWebSocketFrame)         {             System.out.println("WebSocket Client received closing");             ctx.channel().close();        }        else        {            String message = "unsupported frame type: " + frame.getClass().getName();            throw new UnsupportedOperationException(message);        }    }}//import io.netty.buffer.ByteBuf;//import io.netty.buffer.Unpooled;//import io.netty.channel.ChannelFuture;//import io.netty.channel.ChannelFutureListener;//import io.netty.channel.ChannelHandlerContext;//import io.netty.channel.SimpleChannelInboundHandler;//import io.netty.handler.codec.http.DefaultFullHttpResponse;//import io.netty.handler.codec.http.FullHttpRequest;//import io.netty.handler.codec.http.FullHttpResponse;//import io.netty.handler.codec.http.HttpUtil;//import io.netty.handler.codec.http.websocketx.*;//import io.netty.util.CharsetUtil;//import static io.netty.handler.codec.http.HttpResponseStatus.BAD_REQUEST;//import static io.netty.handler.codec.http.HttpVersion.HTTP_1_1;//import org.slf4j.Logger;//import org.slf4j.LoggerFactory;////public class MJWebSocketFrameHandler extends SimpleChannelInboundHandler<Object> //{//    private static final Logger logger = LoggerFactory//            .getLogger(MJWebSocketFrameHandler.class.getName());////    private WebSocketServerHandshaker handshaker;////    @Override//    public void channelRead0(ChannelHandlerContext ctx, Object msg) throws Exception //    {//        // 传统的HTTP接入//		if (msg instanceof FullHttpRequest) //		{//		    handleHttpRequest(ctx, (FullHttpRequest) msg);//		}//		// WebSocket接入//        else if (msg instanceof WebSocketFrame) //        {//            handleWebSocketFrame(ctx, (WebSocketFrame) msg);//        }//    }////    @Override//    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception //    {//        ctx.flush();//    }////    private void handleHttpRequest(ChannelHandlerContext ctx, FullHttpRequest req) throws Exception//    {//        // 如果HTTP解码失败，返回HHTP异常//		if (!req.decoderResult().isSuccess() || (!"websocket".equals(req.headers().get("Upgrade")))) //		{//            sendHttpResponse(ctx, req, new DefaultFullHttpResponse(HTTP_1_1, BAD_REQUEST));//            return;//        }//        // 构造握手响应返回，本机测试//		WebSocketServerHandshakerFactory wsFactory = new WebSocketServerHandshakerFactory("ws://localhost:8080/websocket", null, false);//        handshaker = wsFactory.newHandshaker(req);//        if (handshaker == null)//        {//            WebSocketServerHandshakerFactory.sendUnsupportedVersionResponse(ctx.channel());//        } //        else //        {//            handshaker.handshake(ctx.channel(), req);//        }//    }////    private void handleWebSocketFrame(ChannelHandlerContext ctx, WebSocketFrame frame) //    {//        // 判断是否是关闭链路的指令//		if (frame instanceof CloseWebSocketFrame) {//		    handshaker.close(ctx.channel(), (CloseWebSocketFrame) frame.retain());//		    return;//		}//		// 判断是否是Ping消息//		if (frame instanceof PingWebSocketFrame) //		{//		    ctx.channel().write(new PongWebSocketFrame(frame.content().retain()));//		    return;//		}//		// 本例程仅支持文本消息，不支持二进制消息//		if (!(frame instanceof TextWebSocketFrame))//		{//		    throw new UnsupportedOperationException(String.format("%s frame types not supported", frame.getClass().getName()));//		}//		// 返回应答消息//		String request = ((TextWebSocketFrame) frame).text();//		logger.info(String.format("%s received %s", ctx.channel(), request));//		ctx.channel().write(new TextWebSocketFrame(request + " , 欢迎使用Netty WebSocket服务，现在时刻：" + new java.util.Date().toString()));//    }////    private static void sendHttpResponse(ChannelHandlerContext ctx, FullHttpRequest req, FullHttpResponse res) //    {//        // 返回应答给客户端//        if (res.getStatus().code() != 200) //        {//            ByteBuf buf = Unpooled.copiedBuffer(res.getStatus().toString(),//                    CharsetUtil.UTF_8);//            res.content().writeBytes(buf);//            buf.release();//            HttpUtil.setContentLength(res, res.content().readableBytes());//        }//        // 如果是非Keep-Alive，关闭连接//        ChannelFuture f = ctx.channel().writeAndFlush(res);//        if (!HttpUtil.isKeepAlive(req) || res.status().code() != 200) //        {//            f.addListener(ChannelFutureListener.CLOSE);//        }//    }////    @Override//    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception //    {//        cause.printStackTrace();//        ctx.close();//    }//}